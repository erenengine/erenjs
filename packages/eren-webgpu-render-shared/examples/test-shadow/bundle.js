(()=>{"use strict";var e,t,r,n,i={4:(e,t,r)=>{r.d(t,{w:()=>i});var n=r(719);function i(e,t,r){const i=(0,n.k)(t),o=4*i.length,a=r.length,s=o+3&-4,u=s+2*a,d=e.createBuffer({label:"Test Buffer",size:u,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),c=new Uint8Array(d.getMappedRange());return new Float32Array(c.buffer).set(i),new Uint16Array(c.buffer,s,a).set(r),d.unmap(),{buffer:d,vertexOffset:0,indexOffset:s,indexCount:a}}},422:(e,t,r)=>{r.d(t,{O:()=>f});var n=r(429),i=r(531);function o(){var e=new i.tb(16);return i.tb!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function a(e,t,r,n){var o,a,s,u,d,c,p,l,f,h,m=t[0],b=t[1],w=t[2],v=n[0],g=n[1],x=n[2],y=r[0],P=r[1],S=r[2];return Math.abs(m-y)<i.p8&&Math.abs(b-P)<i.p8&&Math.abs(w-S)<i.p8?function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}(e):(p=m-y,l=b-P,f=w-S,o=g*(f*=h=1/Math.hypot(p,l,f))-x*(l*=h),a=x*(p*=h)-v*f,s=v*l-g*p,(h=Math.hypot(o,a,s))?(o*=h=1/h,a*=h,s*=h):(o=0,a=0,s=0),u=l*s-f*a,d=f*o-p*s,c=p*a-l*o,(h=Math.hypot(u,d,c))?(u*=h=1/h,d*=h,c*=h):(u=0,d=0,c=0),e[0]=o,e[1]=u,e[2]=p,e[3]=0,e[4]=a,e[5]=d,e[6]=l,e[7]=0,e[8]=s,e[9]=c,e[10]=f,e[11]=0,e[12]=-(o*m+a*b+s*w),e[13]=-(u*m+d*b+c*w),e[14]=-(p*m+l*b+f*w),e[15]=1,e)}const s={r:.1921,g:.302,b:.4745,a:1};class u{#e;#t;#r;#n;#i;constructor(e,t,r){this.#e=e;const n=e.createShaderModule({label:"Debug Quad Shader",code:"struct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) fragUV: vec2<f32>,\n};\n\n@vertex\nfn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var positions = array<vec2<f32>, 3>(\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>(-1.0,  3.0),\n        vec2<f32>( 3.0, -1.0)\n    );\n\n    var uvs = array<vec2<f32>, 3>(\n        vec2<f32>(0.0, 0.0),\n        vec2<f32>(0.0, 2.0),\n        vec2<f32>(2.0, 0.0)\n    );\n\n    var output: VertexOutput;\n    output.position = vec4<f32>(positions[vertexIndex], 0.0, 1.0);\n    output.fragUV = uvs[vertexIndex];\n    return output;\n}\n\n@group(0) @binding(0)\nvar shadowMap: texture_depth_2d;\n\n@group(0) @binding(1)\nvar shadowSampler: sampler_comparison;\n\n@fragment\nfn fs_main(@location(0) fragUV: vec2<f32>) -> @location(0) vec4<f32> {\n    // 예를 들어 기준 깊이값을 0.5로 설정\n    let depth: f32 = textureSampleCompare(shadowMap, shadowSampler, fragUV, 0.5);\n    return vec4<f32>(vec3<f32>(depth), 1.0);\n}\n"});this.#t=e.createBindGroupLayout({label:"Debug Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"depth",viewDimension:"2d",multisampled:!1}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"comparison"}}]}),this.#r=e.createSampler({label:"Debug Quad Sampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge",compare:"less"}),this.#n=this.#o(r);const i=e.createPipelineLayout({label:"Debug Pipeline Layout",bindGroupLayouts:[this.#t]});this.#i=e.createRenderPipeline({label:"Debug Quad Pipeline",layout:i,vertex:{module:n,entryPoint:"vs_main"},fragment:{module:n,entryPoint:"fs_main",targets:[{format:t}]}})}rebindShadowTexture(e){this.#n=this.#o(e)}#o(e){return this.#e.createBindGroup({label:"Debug Bind Group",layout:this.#t,entries:[{binding:0,resource:e},{binding:1,resource:this.#r}]})}recordCommands(e,t){const r=e.beginRenderPass({colorAttachments:[{view:t,loadOp:"clear",storeOp:"store",clearValue:s}]});r.setPipeline(this.#i),r.setBindGroup(0,this.#n),r.draw(3,1,0,0),r.end()}}var d=r(719);class c{shadowTextureView;#e;#a;#n;#i;constructor(e,t,r){this.#e=e;const n=e.createShaderModule({label:"Shadow Shader",code:"struct ShadowUBO {\n    lightViewProj: mat4x4<f32>,\n};\n\n@group(0) @binding(0)\nvar<uniform> ubo: ShadowUBO;\n\nstruct VertexInput {\n    @location(0) inPosition: vec3<f32>,\n};\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n};\n\n@vertex\nfn vs_main(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n    output.position = ubo.lightViewProj * vec4<f32>(input.inPosition, 1.0);\n    return output;\n}\n"});this.#a=e.createBuffer({label:"Shadow UBO",size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const i=e.createBindGroupLayout({label:"Shadow Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]});this.#n=e.createBindGroup({label:"Shadow Bind Group",layout:i,entries:[{binding:0,resource:{buffer:this.#a}}]});const o=e.createPipelineLayout({label:"Shadow Pipeline Layout",bindGroupLayouts:[i]});this.#i=e.createRenderPipeline({label:"Shadow Pipeline",layout:o,vertex:{module:n,entryPoint:"vs_main",buffers:[d.x]},primitive:{cullMode:"back",frontFace:"ccw",topology:"triangle-list"},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less",depthBias:2,depthBiasSlopeScale:4,depthBiasClamp:0}}),this.shadowTextureView=this.#s(t,r)}#s(e,t){return this.#e.createTexture({label:"Shadow Depth Texture",size:{width:e,height:t},format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}).createView()}resizeShadowTexture(e,t){this.shadowTextureView=this.#s(e,t)}updateShadowUBO(e){this.#e.queue.writeBuffer(this.#a,0,function(e){const t=new Float32Array(16);return t.set(e.lightViewProj,0),t}(e))}recordCommands(e,t){const r=e.beginRenderPass({colorAttachments:[],depthStencilAttachment:{view:this.shadowTextureView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});r.setPipeline(this.#i),r.setBindGroup(0,this.#n);for(const e of t)r.setVertexBuffer(0,e.buffer,e.vertexOffset),r.setIndexBuffer(e.buffer,"uint16",e.indexOffset),r.drawIndexed(e.indexCount,1,0,0,0);r.end()}}const p={r:.1921,g:.302,b:.4745,a:1};class l{#e;#i;#u;#d;#c;#p;#l;#f;#h;constructor(e,t,r,n,i){this.#e=e;const o=e.createShaderModule({label:"Main Shader",code:"struct MainUBO {\n    model: mat4x4<f32>,\n    view: mat4x4<f32>,\n    proj: mat4x4<f32>,\n    lightViewProj: mat4x4<f32>,\n};\n\n@group(0) @binding(0)\nvar<uniform> ubo: MainUBO;\n\nstruct VertexInput {\n    @location(0) inPosition: vec3<f32>,\n    @location(1) inNormal: vec3<f32>,\n};\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) fragPosWorld: vec3<f32>,\n    @location(1) normalWorld: vec3<f32>,\n    @location(2) shadowCoord: vec4<f32>,\n};\n\nfn inverse_mat3(m: mat3x3<f32>) -> mat3x3<f32> {\n    let a = m[0];\n    let b = m[1];\n    let c = m[2];\n\n    let r0 = cross(b, c);\n    let r1 = cross(c, a);\n    let r2 = cross(a, b);\n\n    let inv_det = 1.0 / dot(r2, c);\n\n    return mat3x3<f32>(r0, r1, r2) * inv_det;\n}\n\n@vertex\nfn vs_main(input: VertexInput) -> VertexOutput {\n    var out: VertexOutput;\n\n    let worldPos = ubo.model * vec4<f32>(input.inPosition, 1.0);\n    out.fragPosWorld = worldPos.xyz;\n\n    let model3x3 = mat3x3<f32>(\n        ubo.model[0].xyz,\n        ubo.model[1].xyz,\n        ubo.model[2].xyz\n    );\n\n    out.normalWorld = inverse_mat3(model3x3) * input.inNormal;\n    out.shadowCoord = ubo.lightViewProj * worldPos;\n\n    out.position = ubo.proj * ubo.view * worldPos;\n    return out;\n}\n\n@group(1) @binding(0)\nvar shadowMap: texture_depth_2d;\n\n@group(1) @binding(1)\nvar shadowSampler: sampler_comparison;\n\nstruct Light {\n    direction: vec3<f32>,\n    color: vec3<f32>,\n};\n\n@group(0) @binding(1)\nvar<uniform> light: Light;\n\nstruct FragmentInput {\n    @location(0) fragPosWorld: vec3<f32>,\n    @location(1) normalWorld: vec3<f32>,\n    @location(2) shadowCoord: vec4<f32>,\n};\n\n@fragment\nfn fs_main(input: FragmentInput) -> @location(0) vec4<f32> {\n    let norm = normalize(input.normalWorld);\n    let lightDir = normalize(-light.direction);\n\n    let ambientStrength = 0.1;\n    let ambient = ambientStrength * light.color;\n\n    let diff = max(dot(norm, lightDir), 0.0);\n    let diffuse = light.color * diff;\n\n    let projCoords = input.shadowCoord;\n    let shadowTexCoord = vec2(\n        projCoords.x * 0.5 + 0.5,\n        projCoords.y * -0.5 + 0.5\n    );\n    let currentDepth = projCoords.z;\n\n    let texelSize = 1.0 / 2048.0;\n\n    var shadow = 0.0;\n\n    for (var x: i32 = -1; x <= 1; x = x + 1) {\n        for (var y: i32 = -1; y <= 1; y = y + 1) {\n            let offset = vec2<f32>(f32(x), f32(y)) * texelSize;\n            let coord = shadowTexCoord + offset;\n\n            // 텍스처 범위 내 여부 확인\n            let in_bounds = all(coord >= vec2(0.0)) && all(coord <= vec2(1.0)) && currentDepth <= 1.0;\n\n            // 항상 호출하되, 결과를 마스킹\n            let comparison = textureSampleCompare(\n                shadowMap,\n                shadowSampler,\n                coord,\n                currentDepth\n            );\n\n            shadow = shadow + f32(comparison < 1.0) * f32(in_bounds);\n        }\n    }\n\n    shadow = shadow / 9.0;\n\n    var baseColor: vec3<f32>;\n    if (input.fragPosWorld.y == -1.0) {\n        baseColor = vec3<f32>(0.8, 0.8, 0.8);\n    } else {\n        baseColor = vec3<f32>(1.0, 0.7, 0.2);\n    }\n\n    let lighting = ambient + (1.0 - shadow) * diffuse;\n\n    return vec4<f32>(baseColor * lighting, 1.0);\n}\n"}),a=e.createBindGroupLayout({label:"Main UBO Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]});this.#p=e.createBindGroupLayout({label:"Shadow Sampler Layout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d",multisampled:!1,sampleType:"depth"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"comparison"}}]}),this.#l=e.createSampler({label:"Shadow Map Sampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge",minFilter:"nearest",magFilter:"nearest",mipmapFilter:"nearest",compare:"less"}),this.#u=e.createBuffer({label:"MainUBO",size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.#d=e.createBuffer({label:"LightUBO",size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.#c=e.createBindGroup({label:"Main Bind Group",layout:a,entries:[{binding:0,resource:{buffer:this.#u}},{binding:1,resource:{buffer:this.#d}}]}),this.#f=this.#m(r);const s=e.createPipelineLayout({label:"Main Pipeline Layout",bindGroupLayouts:[a,this.#p]});this.#i=e.createRenderPipeline({label:"Main Pipeline",layout:s,vertex:{module:o,entryPoint:"vs_main",buffers:[d.x]},fragment:{module:o,entryPoint:"fs_main",targets:[{format:t,blend:{color:{operation:"add",srcFactor:"one",dstFactor:"zero"},alpha:{operation:"add",srcFactor:"one",dstFactor:"zero"}},writeMask:GPUColorWrite.ALL}]},primitive:{cullMode:"back",frontFace:"ccw",topology:"triangle-list"},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"}}),this.#h=this.#b(n,i)}updateMainUBO(e){this.#e.queue.writeBuffer(this.#u,0,function(e){const t=new Float32Array(64);return t.set(e.model,0),t.set(e.view,16),t.set(e.proj,32),t.set(e.lightViewProj,48),t}(e))}updateLightUBO(e){this.#e.queue.writeBuffer(this.#d,0,function(e){const t=new Float32Array(8);return t.set(e.direction,0),t.set(e.color,4),t}(e))}resizeDepthTexture(e,t,r){this.#f=this.#m(r),this.#h=this.#b(e,t)}recordCommands(e,t,r){const n=e.beginRenderPass({label:"Main Render Pass",colorAttachments:[{view:t,loadOp:"clear",storeOp:"store",clearValue:p}],depthStencilAttachment:{view:this.#h,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});n.setPipeline(this.#i),n.setBindGroup(0,this.#c),n.setBindGroup(1,this.#f);for(const e of r)n.setVertexBuffer(0,e.buffer,e.vertexOffset),n.setIndexBuffer(e.buffer,"uint16",e.indexOffset),n.drawIndexed(e.indexCount,1,0,0,0);n.end()}#m(e){return this.#e.createBindGroup({label:"Shadow Bind Group",layout:this.#p,entries:[{binding:0,resource:e},{binding:1,resource:this.#l}]})}#b(e,t){return this.#e.createTexture({label:"Scene Depth Texture",size:{width:e,height:t},format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}).createView()}}class f{#e;#w;#v;#g;#x;constructor(e,t,r,n){this.#e=e,this.#w=new c(e,r,n),this.#v=new u(e,t,this.#w.shadowTextureView),this.#g=new l(e,t,this.#w.shadowTextureView,r,n),this.#x=performance.now()}resize(e,t){this.#w.resizeShadowTexture(e,t),this.#v.rebindShadowTexture(this.#w.shadowTextureView),this.#g.resizeDepthTexture(e,t,this.#w.shadowTextureView)}render(e,t,r,i){const s=this.#e.createCommandEncoder({label:"Test Render Encoder"}),u=(performance.now()-this.#x)/1e3,d=8*Math.cos(.4*u),c=8*Math.sin(.4*u),p=n.fA(d,6,c),l=o();var f,h,m,b,w,v,g,x,y,P;x=1/((h=-10)-(m=10)),y=1/((b=-10)-(w=10)),P=1/((v=-10)-(g=20)),(f=l)[0]=-2*x,f[1]=0,f[2]=0,f[3]=0,f[4]=0,f[5]=-2*y,f[6]=0,f[7]=0,f[8]=0,f[9]=0,f[10]=2*P,f[11]=0,f[12]=(h+m)*x,f[13]=(w+b)*y,f[14]=(g+v)*P,f[15]=1;const S=o();a(S,p,n.fA(0,0,0),n.fA(0,1,0));const A=o();(function(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3],s=t[4],u=t[5],d=t[6],c=t[7],p=t[8],l=t[9],f=t[10],h=t[11],m=t[12],b=t[13],w=t[14],v=t[15],g=r[0],x=r[1],y=r[2],P=r[3];e[0]=g*n+x*s+y*p+P*m,e[1]=g*i+x*u+y*l+P*b,e[2]=g*o+x*d+y*f+P*w,e[3]=g*a+x*c+y*h+P*v,g=r[4],x=r[5],y=r[6],P=r[7],e[4]=g*n+x*s+y*p+P*m,e[5]=g*i+x*u+y*l+P*b,e[6]=g*o+x*d+y*f+P*w,e[7]=g*a+x*c+y*h+P*v,g=r[8],x=r[9],y=r[10],P=r[11],e[8]=g*n+x*s+y*p+P*m,e[9]=g*i+x*u+y*l+P*b,e[10]=g*o+x*d+y*f+P*w,e[11]=g*a+x*c+y*h+P*v,g=r[12],x=r[13],y=r[14],P=r[15],e[12]=g*n+x*s+y*p+P*m,e[13]=g*i+x*u+y*l+P*b,e[14]=g*o+x*d+y*f+P*w,e[15]=g*a+x*c+y*h+P*v})(A,l,S),this.#w.updateShadowUBO({lightViewProj:A}),this.#w.recordCommands(s,t);{const d=n.fA(8*Math.cos(.2*u),6,8*Math.sin(.2*u)),c=o();a(c,d,n.fA(0,0,0),n.fA(0,1,0));const l=o();!function(e,t,r,n,i){var o,a=1/Math.tan(t/2);e[0]=a/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(o=1/(n-i),e[10]=(i+n)*o,e[14]=2*i*n*o):(e[10]=-1,e[14]=-2*n)}(l,45*Math.PI/180,r/i,.1,100);const f={model:o(),view:c,proj:l,lightViewProj:A};this.#g.updateMainUBO(f);const h=n.vt();n.Re(h,n.fA(0,0,0),p),n.S8(h,h);const m={direction:h,color:n.fA(1,1,1)};this.#g.updateLightUBO(m),this.#g.recordCommands(s,e,t)}this.#e.queue.submit([s.finish()])}}},429:(e,t,r)=>{r.d(t,{Re:()=>a,S8:()=>s,fA:()=>o,vt:()=>i});var n=r(531);function i(){var e=new n.tb(3);return n.tb!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function o(e,t,r){var i=new n.tb(3);return i[0]=e,i[1]=t,i[2]=r,i}function a(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e}function s(e,t){var r=t[0],n=t[1],i=t[2],o=r*r+n*n+i*i;return o>0&&(o=1/Math.sqrt(o)),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e}i()},453:(e,t,r)=>{r.d(t,{Y:()=>n});class n{#y;constructor(e){this.#y=e}static async create(e){const t=await e.requestAdapter();return new n(t)}requestDevice(){return this.#y.requestDevice()}}},531:(e,t,r)=>{r.d(t,{p8:()=>n,tb:()=>i});var n=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)})},543:(e,t,r)=>{r.d(t,{c:()=>n});class n{#P;preferredFormat;constructor(){if(!navigator.gpu)throw new Error("WebGPU support is not available");this.#P=navigator.gpu,this.preferredFormat=navigator.gpu.getPreferredCanvasFormat()}async requestAdapter(){const e=await this.#P.requestAdapter({powerPreference:"high-performance",forceFallbackAdapter:!1});if(!e)throw new Error("Failed to request Adapter.");return e}}},562:(e,t,r)=>{r.d(t,{p:()=>n});class n{#e;queue;constructor(e,t){this.#e=e,this.queue=t}static async create(e,t,r){const i=await e.requestDevice();return t.configure({device:i,format:r,alphaMode:"opaque"}),new n(i,i.queue)}createShaderModule(e){return this.#e.createShaderModule(e)}createPipelineLayout(e){return this.#e.createPipelineLayout(e)}createComputePipeline(e){return this.#e.createComputePipeline(e)}createRenderPipeline(e){return this.#e.createRenderPipeline(e)}createCommandEncoder(e){return this.#e.createCommandEncoder(e)}createBuffer(e){return this.#e.createBuffer(e)}createBindGroupLayout(e){return this.#e.createBindGroupLayout(e)}createBindGroup(e){return this.#e.createBindGroup(e)}createTexture(e){return this.#e.createTexture(e)}createSampler(e){return this.#e.createSampler(e)}}},719:(e,t,r)=>{r.d(t,{k:()=>o,x:()=>i});const n=6,i={arrayStride:24,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"}]};function o(e){const t=new Float32Array(e.length*n);for(let r=0;r<e.length;r++){const i=r*n;t.set(e[r].position,i+0),t.set(e[r].normal,i+3)}return t}},797:(e,t,r)=>{r.d(t,{o:()=>n});class n{#S;constructor(e){const t=e.getContext("webgpu");if(!t)throw new Error("Failed to get WebGPU context");this.#S=t}configure(e){this.#S.configure(e)}getCurrentTexture(){return this.#S.getCurrentTexture()}}},805:(e,t,r)=>{r.a(e,async(e,t)=>{try{var n=r(543),i=r(453),o=r(797),a=r(562),s=r(422),u=r(429),d=r(4);const c=document.getElementById("canvas"),p=new n.c,l=await i.Y.create(p),f=new o.o(c),h=await a.p.create(l,f,p.preferredFormat),m=new s.O(h,p.preferredFormat,c.width,c.height);function b(){const e=u.fA(0,1,0);return{vertices:[u.fA(-5,-1,-5),u.fA(5,-1,-5),u.fA(5,-1,5),u.fA(-5,-1,5)].map(t=>({position:t,normal:e})),indices:[0,2,1,2,0,3]}}const w=b(),v={vertices:[[u.fA(-.5,-.5,.5),u.fA(0,0,1)],[u.fA(.5,-.5,.5),u.fA(0,0,1)],[u.fA(.5,.5,.5),u.fA(0,0,1)],[u.fA(-.5,.5,.5),u.fA(0,0,1)],[u.fA(.5,-.5,-.5),u.fA(0,0,-1)],[u.fA(-.5,-.5,-.5),u.fA(0,0,-1)],[u.fA(-.5,.5,-.5),u.fA(0,0,-1)],[u.fA(.5,.5,-.5),u.fA(0,0,-1)],[u.fA(-.5,.5,.5),u.fA(0,1,0)],[u.fA(.5,.5,.5),u.fA(0,1,0)],[u.fA(.5,.5,-.5),u.fA(0,1,0)],[u.fA(-.5,.5,-.5),u.fA(0,1,0)],[u.fA(-.5,-.5,-.5),u.fA(0,-1,0)],[u.fA(.5,-.5,-.5),u.fA(0,-1,0)],[u.fA(.5,-.5,.5),u.fA(0,-1,0)],[u.fA(-.5,-.5,.5),u.fA(0,-1,0)],[u.fA(.5,-.5,.5),u.fA(1,0,0)],[u.fA(.5,-.5,-.5),u.fA(1,0,0)],[u.fA(.5,.5,-.5),u.fA(1,0,0)],[u.fA(.5,.5,.5),u.fA(1,0,0)],[u.fA(-.5,-.5,-.5),u.fA(-1,0,0)],[u.fA(-.5,-.5,.5),u.fA(-1,0,0)],[u.fA(-.5,.5,.5),u.fA(-1,0,0)],[u.fA(-.5,.5,-.5),u.fA(-1,0,0)]].map(e=>({position:e[0],normal:e[1]})),indices:[0,1,2,2,3,0,4,5,6,6,7,4,8,9,10,10,11,8,12,13,14,14,15,12,16,17,18,18,19,16,20,21,22,22,23,20]},g=[(0,d.w)(h,w.vertices,w.indices),(0,d.w)(h,v.vertices,v.indices)];function x(){m.render(f.getCurrentTexture().createView(),g,c.width,c.height),requestAnimationFrame(x)}x(),t()}catch(y){t(y)}},1)}},o={};function a(e){var t=o[e];if(void 0!==t)return t.exports;var r=o[e]={exports:{}};return i[e](r,r.exports,a),r.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",r="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",n=e=>{e&&e.d<1&&(e.d=1,e.forEach(e=>e.r--),e.forEach(e=>e.r--?e.r++:e()))},a.a=(i,o,a)=>{var s;a&&((s=[]).d=-1);var u,d,c,p=new Set,l=i.exports,f=new Promise((e,t)=>{c=t,d=e});f[t]=l,f[e]=e=>(s&&e(s),p.forEach(e),f.catch(e=>{})),i.exports=f,o(i=>{var o;u=(i=>i.map(i=>{if(null!==i&&"object"==typeof i){if(i[e])return i;if(i.then){var o=[];o.d=0,i.then(e=>{a[t]=e,n(o)},e=>{a[r]=e,n(o)});var a={};return a[e]=e=>e(o),a}}var s={};return s[e]=e=>{},s[t]=i,s}))(i);var a=()=>u.map(e=>{if(e[r])throw e[r];return e[t]}),d=new Promise(t=>{(o=()=>t(a)).r=0;var r=e=>e!==s&&!p.has(e)&&(p.add(e),e&&!e.d&&(o.r++,e.push(o)));u.map(t=>t[e](r))});return o.r?d:a()},e=>(e?c(f[r]=e):d(l),n(s))),s&&s.d<0&&(s.d=0)},a.d=(e,t)=>{for(var r in t)a.o(t,r)&&!a.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a(805)})();