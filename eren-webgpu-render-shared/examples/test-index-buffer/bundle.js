(()=>{"use strict";var e,t,r,n,o={348:(e,t,r)=>{r.a(e,async(e,t)=>{try{var n=r(543),o=r(453),a=r(797),i=r(562),c=r(580);const s=document.getElementById("canvas"),u=new n.c,f=await o.Y.create(u),d=new a.o(s),p=await i.p.create(f,d,u.preferredFormat),l=new c.O(p,u.preferredFormat);function h(){l.render(d.getCurrentTexture().createView()),requestAnimationFrame(h)}h(),t()}catch(v){t(v)}},1)},453:(e,t,r)=>{r.d(t,{Y:()=>n});class n{#e;constructor(e){this.#e=e}static async create(e){const t=await e.requestAdapter();return new n(t)}requestDevice(){return this.#e.requestDevice()}}},543:(e,t,r)=>{r.d(t,{c:()=>n});class n{#t;preferredFormat;constructor(){if(!navigator.gpu)throw new Error("WebGPU support is not available");this.#t=navigator.gpu,this.preferredFormat=navigator.gpu.getPreferredCanvasFormat()}async requestAdapter(){const e=await this.#t.requestAdapter({powerPreference:"high-performance",forceFallbackAdapter:!1});if(!e)throw new Error("Failed to request Adapter.");return e}}},562:(e,t,r)=>{r.d(t,{p:()=>n});class n{#r;queue;constructor(e,t){this.#r=e,this.queue=t}static async create(e,t,r){const o=await e.requestDevice();return t.configure({device:o,format:r,alphaMode:"opaque"}),new n(o,o.queue)}createShaderModule(e){return this.#r.createShaderModule(e)}createPipelineLayout(e){return this.#r.createPipelineLayout(e)}createRenderPipeline(e){return this.#r.createRenderPipeline(e)}createCommandEncoder(e){return this.#r.createCommandEncoder(e)}createBuffer(e){return this.#r.createBuffer(e)}createBindGroupLayout(e){return this.#r.createBindGroupLayout(e)}createBindGroup(e){return this.#r.createBindGroup(e)}}},580:(e,t,r)=>{r.d(t,{O:()=>p});const n={arrayStride:20,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x3"}]};var o,a="undefined"!=typeof Float32Array?Float32Array:Array;function i(e,t){var r=new a(2);return r[0]=e,r[1]=t,r}function c(e,t,r){var n=new a(3);return n[0]=e,n[1]=t,n[2]=r,n}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),o=new a(2),a!=Float32Array&&(o[0]=0,o[1]=0),function(){var e=new a(3);a!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0)}();const s={r:.1921,g:.302,b:.4745,a:1},u=[{pos:i(-.5,-.5),color:c(1,0,0)},{pos:i(.5,-.5),color:c(0,1,0)},{pos:i(.5,.5),color:c(0,0,1)},{pos:i(-.5,.5),color:c(1,1,1)}],f=[0,1,2,2,3,0];class d{#r;#n;#o;constructor(e,t){this.#r=e;let r=e.createShaderModule({label:"Test Shader",code:"// 정점 입력 구조체 (vertex buffer layout에서 제공)\nstruct VertexInput {\n    @location(0) inPosition : vec2<f32>,\n    @location(1) inColor    : vec3<f32>,\n};\n\n// 정점 출력 구조체\nstruct VertexOutput {\n    @builtin(position) position : vec4<f32>,\n    @location(0) fragColor : vec3<f32>,\n};\n\n@vertex\nfn vs_main(input : VertexInput) -> VertexOutput {\n    var output : VertexOutput;\n    \n    // GLSL과 동일한 방식의 모델-뷰-프로젝션 변환\n    let pos = vec4<f32>(input.inPosition, 0.0, 1.0);\n    output.position = pos;\n    \n    output.fragColor = input.inColor;\n    return output;\n}\n\n@fragment\nfn fs_main(@location(0) fragColor : vec3<f32>) -> @location(0) vec4<f32> {\n    return vec4<f32>(fragColor, 1.0);\n}\n"}),o=e.createPipelineLayout({label:"Test Pipeline Layout",bindGroupLayouts:[]});this.#n=e.createRenderPipeline({label:"Test Pipeline",layout:o,vertex:{module:r,entryPoint:"vs_main",buffers:[n]},fragment:{module:r,entryPoint:"fs_main",targets:[{format:t}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint16"}}),this.#o=function(e){const t=function(e){const t=new Float32Array(5*e.length);for(let r=0;r<e.length;r++){const n=5*r;t.set(e[r].pos,n+0),t.set(e[r].color,n+2)}return t}(u),r=t.length,n=f.length,o=4*r+3&-4,a=o+2*n,i=e.createBuffer({label:"Test Buffer",size:a,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),c=new Uint8Array(i.getMappedRange());return new Float32Array(c.buffer).set(t),new Uint16Array(c.buffer,o,n).set(f),i.unmap(),{buffer:i,vertexOffset:0,indexOffset:o,indexCount:n}}(e)}recordCommands(e,t){const r=e.beginRenderPass({colorAttachments:[{view:t,loadOp:"clear",storeOp:"store",clearValue:s}]});r.setPipeline(this.#n),r.setVertexBuffer(0,this.#o.buffer,this.#o.vertexOffset),r.setIndexBuffer(this.#o.buffer,"uint16",this.#o.indexOffset),r.drawIndexed(this.#o.indexCount,1,0,0,0),r.end()}}class p{#r;#a;constructor(e,t){this.#r=e,this.#a=new d(e,t)}render(e){const t=this.#r.createCommandEncoder({label:"Test Render Encoder"});this.#a.recordCommands(t,e),this.#r.queue.submit([t.finish()])}}},797:(e,t,r)=>{r.d(t,{o:()=>n});class n{#i;constructor(e){const t=e.getContext("webgpu");if(!t)throw new Error("Failed to get WebGPU context");this.#i=t}configure(e){this.#i.configure(e)}getCurrentTexture(){return this.#i.getCurrentTexture()}}}},a={};function i(e){var t=a[e];if(void 0!==t)return t.exports;var r=a[e]={exports:{}};return o[e](r,r.exports,i),r.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",r="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",n=e=>{e&&e.d<1&&(e.d=1,e.forEach(e=>e.r--),e.forEach(e=>e.r--?e.r++:e()))},i.a=(o,a,i)=>{var c;i&&((c=[]).d=-1);var s,u,f,d=new Set,p=o.exports,l=new Promise((e,t)=>{f=t,u=e});l[t]=p,l[e]=e=>(c&&e(c),d.forEach(e),l.catch(e=>{})),o.exports=l,a(o=>{var a;s=(o=>o.map(o=>{if(null!==o&&"object"==typeof o){if(o[e])return o;if(o.then){var a=[];a.d=0,o.then(e=>{i[t]=e,n(a)},e=>{i[r]=e,n(a)});var i={};return i[e]=e=>e(a),i}}var c={};return c[e]=e=>{},c[t]=o,c}))(o);var i=()=>s.map(e=>{if(e[r])throw e[r];return e[t]}),u=new Promise(t=>{(a=()=>t(i)).r=0;var r=e=>e!==c&&!d.has(e)&&(d.add(e),e&&!e.d&&(a.r++,e.push(a)));s.map(t=>t[e](r))});return a.r?u:i()},e=>(e?f(l[r]=e):u(p),n(c))),c&&c.d<0&&(c.d=0)},i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i(348)})();