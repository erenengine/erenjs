(()=>{"use strict";var e,r,t,n,o={344:(e,r,t)=>{t.a(e,async(e,r)=>{try{var n=t(543),o=t(453),a=t(797),i=t(562),c=t(728);const s=document.getElementById("canvas"),u=new n.c,p=await o.Y.create(u),d=new a.o(s),f=await i.p.create(p,d,u.preferredFormat),l=new c.O(f,u.preferredFormat);function h(){l.render(d.getCurrentTexture().createView()),requestAnimationFrame(h)}h(),r()}catch(v){r(v)}},1)},453:(e,r,t)=>{t.d(r,{Y:()=>n});class n{#e;constructor(e){this.#e=e}static async create(e){const r=await e.requestAdapter();return new n(r)}requestDevice(){return this.#e.requestDevice()}}},543:(e,r,t)=>{t.d(r,{c:()=>n});class n{#r;preferredFormat;constructor(){if(!navigator.gpu)throw new Error("WebGPU support is not available");this.#r=navigator.gpu,this.preferredFormat=navigator.gpu.getPreferredCanvasFormat()}async requestAdapter(){const e=await this.#r.requestAdapter({powerPreference:"high-performance",forceFallbackAdapter:!1});if(!e)throw new Error("Failed to request Adapter.");return e}}},562:(e,r,t)=>{t.d(r,{p:()=>n});class n{#t;queue;constructor(e,r){this.#t=e,this.queue=r}static async create(e,r,t){const o=await e.requestDevice();return r.configure({device:o,format:t,alphaMode:"opaque"}),new n(o,o.queue)}createShaderModule(e){return this.#t.createShaderModule(e)}createPipelineLayout(e){return this.#t.createPipelineLayout(e)}createRenderPipeline(e){return this.#t.createRenderPipeline(e)}createCommandEncoder(e){return this.#t.createCommandEncoder(e)}createBuffer(e){return this.#t.createBuffer(e)}createBindGroupLayout(e){return this.#t.createBindGroupLayout(e)}createBindGroup(e){return this.#t.createBindGroup(e)}}},728:(e,r,t)=>{t.d(r,{O:()=>d});const n={arrayStride:20,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x3"}]};var o,a="undefined"!=typeof Float32Array?Float32Array:Array;function i(e,r){var t=new a(2);return t[0]=e,t[1]=r,t}function c(e,r,t){var n=new a(3);return n[0]=e,n[1]=r,n[2]=t,n}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,r=arguments.length;r--;)e+=arguments[r]*arguments[r];return Math.sqrt(e)}),o=new a(2),a!=Float32Array&&(o[0]=0,o[1]=0),function(){var e=new a(3);a!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0)}();const s={r:.1921,g:.302,b:.4745,a:1},u=[{pos:i(-.5,-.5),color:c(1,0,0)},{pos:i(.5,-.5),color:c(0,1,0)},{pos:i(.5,.5),color:c(0,0,1)},{pos:i(.5,.5),color:c(0,0,1)},{pos:i(-.5,.5),color:c(1,1,1)},{pos:i(-.5,-.5),color:c(1,0,0)}];class p{#t;#n;#o;constructor(e,r){this.#t=e;let t=e.createShaderModule({label:"Test Shader",code:"// 정점 입력 구조체 (vertex buffer layout에서 제공)\nstruct VertexInput {\n    @location(0) inPosition : vec2<f32>,\n    @location(1) inColor    : vec3<f32>,\n};\n\n// 정점 출력 구조체\nstruct VertexOutput {\n    @builtin(position) position : vec4<f32>,\n    @location(0) fragColor : vec3<f32>,\n};\n\n@vertex\nfn vs_main(input : VertexInput) -> VertexOutput {\n    var output : VertexOutput;\n    \n    // GLSL과 동일한 방식의 모델-뷰-프로젝션 변환\n    let pos = vec4<f32>(input.inPosition, 0.0, 1.0);\n    output.position = pos;\n    \n    output.fragColor = input.inColor;\n    return output;\n}\n\n@fragment\nfn fs_main(@location(0) fragColor : vec3<f32>) -> @location(0) vec4<f32> {\n    return vec4<f32>(fragColor, 1.0);\n}\n"}),o=e.createPipelineLayout({label:"Test Pipeline Layout",bindGroupLayouts:[]});this.#n=e.createRenderPipeline({label:"Test Pipeline",layout:o,vertex:{module:t,entryPoint:"vs_main",buffers:[n]},fragment:{module:t,entryPoint:"fs_main",targets:[{format:r}]},primitive:{topology:"triangle-list"}}),this.#o=function(e){const r=function(e){const r=new Float32Array(5*e.length);for(let t=0;t<e.length;t++){const n=5*t;r.set(e[t].pos,n+0),r.set(e[t].color,n+2)}return r}(u),t=4*r.length,n=e.createBuffer({label:"Test Buffer",size:t,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),o=new Uint8Array(n.getMappedRange());return new Float32Array(o.buffer).set(r),n.unmap(),n}(e)}recordCommands(e,r){const t=e.beginRenderPass({colorAttachments:[{view:r,loadOp:"clear",storeOp:"store",clearValue:s}]});t.setPipeline(this.#n),t.setVertexBuffer(0,this.#o,0),t.draw(u.length,1),t.end()}}class d{#t;#a;constructor(e,r){this.#t=e,this.#a=new p(e,r)}render(e){const r=this.#t.createCommandEncoder({label:"Test Render Encoder"});this.#a.recordCommands(r,e),this.#t.queue.submit([r.finish()])}}},797:(e,r,t)=>{t.d(r,{o:()=>n});class n{#i;constructor(e){const r=e.getContext("webgpu");if(!r)throw new Error("Failed to get WebGPU context");this.#i=r}configure(e){this.#i.configure(e)}getCurrentTexture(){return this.#i.getCurrentTexture()}}}},a={};function i(e){var r=a[e];if(void 0!==r)return r.exports;var t=a[e]={exports:{}};return o[e](t,t.exports,i),t.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",r="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",t="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",n=e=>{e&&e.d<1&&(e.d=1,e.forEach(e=>e.r--),e.forEach(e=>e.r--?e.r++:e()))},i.a=(o,a,i)=>{var c;i&&((c=[]).d=-1);var s,u,p,d=new Set,f=o.exports,l=new Promise((e,r)=>{p=r,u=e});l[r]=f,l[e]=e=>(c&&e(c),d.forEach(e),l.catch(e=>{})),o.exports=l,a(o=>{var a;s=(o=>o.map(o=>{if(null!==o&&"object"==typeof o){if(o[e])return o;if(o.then){var a=[];a.d=0,o.then(e=>{i[r]=e,n(a)},e=>{i[t]=e,n(a)});var i={};return i[e]=e=>e(a),i}}var c={};return c[e]=e=>{},c[r]=o,c}))(o);var i=()=>s.map(e=>{if(e[t])throw e[t];return e[r]}),u=new Promise(r=>{(a=()=>r(i)).r=0;var t=e=>e!==c&&!d.has(e)&&(d.add(e),e&&!e.d&&(a.r++,e.push(a)));s.map(r=>r[e](t))});return a.r?u:i()},e=>(e?p(l[t]=e):u(f),n(c))),c&&c.d<0&&(c.d=0)},i.d=(e,r)=>{for(var t in r)i.o(r,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},i.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),i(344)})();