(()=>{"use strict";var e,t,r,n,a={38:(e,t,r)=>{r.d(t,{fA:()=>o,vt:()=>a});var n=r(531);function a(){var e=new n.tb(2);return n.tb!=Float32Array&&(e[0]=0,e[1]=0),e}function o(e,t){var r=new n.tb(2);return r[0]=e,r[1]=t,r}a()},81:(e,t,r)=>{r.d(t,{w:()=>a});var n=r(890);function a(e,t,r){const a=(0,n.k)(t),o=4*a.length,i=r.length,s=o+3&-4,u=s+2*i,d=e.createBuffer({label:"Test Buffer",size:u,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),c=new Uint8Array(d.getMappedRange());return new Float32Array(c.buffer).set(a),new Uint16Array(c.buffer,s,i).set(r),d.unmap(),{buffer:d,vertexOffset:0,indexOffset:s,indexCount:i}}},113:(e,t,r)=>{r.d(t,{O:()=>h});var n=r(429),a=r(531);function o(){var e=new a.tb(16);return a.tb!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function i(e,t,r,n){var o,i,s,u,d,c,l,p,h,f,m=t[0],v=t[1],g=t[2],b=n[0],x=n[1],w=n[2],y=r[0],S=r[1],P=r[2];return Math.abs(m-y)<a.p8&&Math.abs(v-S)<a.p8&&Math.abs(g-P)<a.p8?function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}(e):(l=m-y,p=v-S,h=g-P,o=x*(h*=f=1/Math.hypot(l,p,h))-w*(p*=f),i=w*(l*=f)-b*h,s=b*p-x*l,(f=Math.hypot(o,i,s))?(o*=f=1/f,i*=f,s*=f):(o=0,i=0,s=0),u=p*s-h*i,d=h*o-l*s,c=l*i-p*o,(f=Math.hypot(u,d,c))?(u*=f=1/f,d*=f,c*=f):(u=0,d=0,c=0),e[0]=o,e[1]=u,e[2]=l,e[3]=0,e[4]=i,e[5]=d,e[6]=p,e[7]=0,e[8]=s,e[9]=c,e[10]=h,e[11]=0,e[12]=-(o*m+i*v+s*g),e[13]=-(u*m+d*v+c*g),e[14]=-(l*m+p*v+h*g),e[15]=1,e)}const s={r:.1921,g:.302,b:.4745,a:1};class u{#e;#t;#r;#n;#a;constructor(e,t,r){this.#e=e;const n=e.createShaderModule({label:"Debug Quad Shader",code:"struct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) fragUV: vec2<f32>,\n};\n\n@vertex\nfn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var positions = array<vec2<f32>, 3>(\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>(-1.0,  3.0),\n        vec2<f32>( 3.0, -1.0)\n    );\n\n    var uvs = array<vec2<f32>, 3>(\n        vec2<f32>(0.0, 0.0),\n        vec2<f32>(0.0, 2.0),\n        vec2<f32>(2.0, 0.0)\n    );\n\n    var output: VertexOutput;\n    output.position = vec4<f32>(positions[vertexIndex], 0.0, 1.0);\n    output.fragUV = uvs[vertexIndex];\n    return output;\n}\n\n@group(0) @binding(0)\nvar shadowMap: texture_depth_2d;\n\n@group(0) @binding(1)\nvar shadowSampler: sampler_comparison;\n\n@fragment\nfn fs_main(@location(0) fragUV: vec2<f32>) -> @location(0) vec4<f32> {\n    // 예를 들어 기준 깊이값을 0.5로 설정\n    let depth: f32 = textureSampleCompare(shadowMap, shadowSampler, fragUV, 0.5);\n    return vec4<f32>(vec3<f32>(depth), 1.0);\n}\n"});this.#t=e.createBindGroupLayout({label:"Debug Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"depth",viewDimension:"2d",multisampled:!1}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"comparison"}}]}),this.#r=e.createSampler({label:"Debug Quad Sampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge",compare:"less"}),this.#n=this.#o(r);const a=e.createPipelineLayout({label:"Debug Pipeline Layout",bindGroupLayouts:[this.#t]});this.#a=e.createRenderPipeline({label:"Debug Quad Pipeline",layout:a,vertex:{module:n,entryPoint:"vs_main"},fragment:{module:n,entryPoint:"fs_main",targets:[{format:t}]}})}rebindShadowTexture(e){this.#n=this.#o(e)}#o(e){return this.#e.createBindGroup({label:"Debug Bind Group",layout:this.#t,entries:[{binding:0,resource:e},{binding:1,resource:this.#r}]})}recordCommands(e,t){const r=e.beginRenderPass({colorAttachments:[{view:t,loadOp:"clear",storeOp:"store",clearValue:s}]});r.setPipeline(this.#a),r.setBindGroup(0,this.#n),r.draw(3,1,0,0),r.end()}}var d=r(890);class c{shadowTextureView;#e;#i;#n;#a;constructor(e,t,r){this.#e=e;const n=e.createShaderModule({label:"Shadow Shader",code:"struct ShadowUBO {\n    lightViewProj: mat4x4<f32>,\n};\n\n@group(0) @binding(0)\nvar<uniform> ubo: ShadowUBO;\n\nstruct VertexInput {\n    @location(0) inPosition: vec3<f32>,\n};\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n};\n\n@vertex\nfn vs_main(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n    output.position = ubo.lightViewProj * vec4<f32>(input.inPosition, 1.0);\n    return output;\n}\n"});this.#i=e.createBuffer({label:"Shadow UBO",size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const a=e.createBindGroupLayout({label:"Shadow Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]});this.#n=e.createBindGroup({label:"Shadow Bind Group",layout:a,entries:[{binding:0,resource:{buffer:this.#i}}]});const o=e.createPipelineLayout({label:"Shadow Pipeline Layout",bindGroupLayouts:[a]});this.#a=e.createRenderPipeline({label:"Shadow Pipeline",layout:o,vertex:{module:n,entryPoint:"vs_main",buffers:[d.x]},primitive:{cullMode:"back",frontFace:"ccw",topology:"triangle-list"},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less",depthBias:2,depthBiasSlopeScale:4,depthBiasClamp:0}}),this.shadowTextureView=this.#s(t,r)}#s(e,t){return this.#e.createTexture({label:"Shadow Depth Texture",size:{width:e,height:t},format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}).createView()}resizeShadowTexture(e,t){this.shadowTextureView=this.#s(e,t)}updateShadowUBO(e){this.#e.queue.writeBuffer(this.#i,0,function(e){const t=new Float32Array(16);return t.set(e.lightViewProj,0),t}(e))}recordCommands(e,t){const r=e.beginRenderPass({colorAttachments:[],depthStencilAttachment:{view:this.shadowTextureView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});r.setPipeline(this.#a),r.setBindGroup(0,this.#n);for(const e of t)r.setVertexBuffer(0,e.buffer,e.vertexOffset),r.setIndexBuffer(e.buffer,"uint16",e.indexOffset),r.drawIndexed(e.indexCount,1,0,0,0);r.end()}}const l={r:.1921,g:.302,b:.4745,a:1};class p{#e;#a;#u;#d;#c;#l;#p;#h;#f;bindGroupShadowAndTexture;#m;constructor(e,t,r,n,a,o){const i=e.createTexture({label:"Test Texture",size:{width:o.width,height:o.height},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});e.queue.copyExternalImageToTexture({source:o},{texture:i},{width:o.width,height:o.height}),this.#p=i.createView(),this.#h=e.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear",addressModeU:"repeat",addressModeV:"repeat"}),this.#e=e;const s=e.createShaderModule({label:"Main Shader",code:"struct MainUBO {\n    model: mat4x4<f32>,\n    view: mat4x4<f32>,\n    proj: mat4x4<f32>,\n    lightViewProj: mat4x4<f32>,\n};\n\n@group(0) @binding(0)\nvar<uniform> ubo: MainUBO;\n\nstruct VertexInput {\n    @location(0) inPosition: vec3<f32>,\n    @location(1) inNormal: vec3<f32>,\n    @location(2) inTexCoord: vec2<f32>,\n};\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n\n    @location(0) fragPosWorld: vec3<f32>,\n    @location(1) normalWorld: vec3<f32>,\n    @location(2) shadowCoord: vec4<f32>,\n    @location(3) fragTexCoord: vec2<f32>,\n};\n\nfn inverse_mat3(m: mat3x3<f32>) -> mat3x3<f32> {\n    let a = m[0];\n    let b = m[1];\n    let c = m[2];\n\n    let r0 = cross(b, c);\n    let r1 = cross(c, a);\n    let r2 = cross(a, b);\n\n    let inv_det = 1.0 / dot(r2, c);\n\n    return mat3x3<f32>(r0, r1, r2) * inv_det;\n}\n\n@vertex\nfn vs_main(input: VertexInput) -> VertexOutput {\n    var out: VertexOutput;\n\n    let worldPos = ubo.model * vec4<f32>(input.inPosition, 1.0);\n    out.fragPosWorld = worldPos.xyz;\n\n    let model3x3 = mat3x3<f32>(\n        ubo.model[0].xyz,\n        ubo.model[1].xyz,\n        ubo.model[2].xyz\n    );\n\n    out.normalWorld = inverse_mat3(model3x3) * input.inNormal;\n    out.shadowCoord = ubo.lightViewProj * worldPos;\n    out.fragTexCoord = input.inTexCoord;\n\n    out.position = ubo.proj * ubo.view * worldPos;\n    return out;\n}\n\n@group(1) @binding(0)\nvar shadowMap: texture_depth_2d;\n\n@group(1) @binding(1)\nvar shadowSampler: sampler_comparison;\n\n@group(1) @binding(2)\nvar texture: texture_2d<f32>;\n\n@group(1) @binding(3)\nvar textureSampler: sampler;\n\nstruct Light {\n    direction: vec3<f32>,\n    color: vec3<f32>,\n};\n\n@group(0) @binding(1)\nvar<uniform> light: Light;\n\nstruct FragmentInput {\n    @location(0) fragPosWorld: vec3<f32>,\n    @location(1) normalWorld: vec3<f32>,\n    @location(2) shadowCoord: vec4<f32>,\n    @location(3) fragTexCoord: vec2<f32>,\n};\n\n@fragment\nfn fs_main(input: FragmentInput) -> @location(0) vec4<f32> {\n    let norm = normalize(input.normalWorld);\n    let lightDir = normalize(-light.direction);\n\n    let ambientStrength = 0.1;\n    let ambient = ambientStrength * light.color;\n\n    let diff = max(dot(norm, lightDir), 0.0);\n    let diffuse = light.color * diff;\n\n    let projCoords = input.shadowCoord;\n    let shadowTexCoord = vec2(\n        projCoords.x * 0.5 + 0.5,\n        projCoords.y * -0.5 + 0.5\n    );\n    let currentDepth = projCoords.z;\n\n    let texelSize = 1.0 / 2048.0;\n\n    var shadow = 0.0;\n\n    for (var x: i32 = -1; x <= 1; x = x + 1) {\n        for (var y: i32 = -1; y <= 1; y = y + 1) {\n            let offset = vec2<f32>(f32(x), f32(y)) * texelSize;\n            let coord = shadowTexCoord + offset;\n\n            // 텍스처 범위 내 여부 확인\n            let in_bounds = all(coord >= vec2(0.0)) && all(coord <= vec2(1.0)) && currentDepth <= 1.0;\n\n            // 항상 호출하되, 결과를 마스킹\n            let comparison = textureSampleCompare(\n                shadowMap,\n                shadowSampler,\n                coord,\n                currentDepth\n            );\n\n            shadow = shadow + f32(comparison < 1.0) * f32(in_bounds);\n        }\n    }\n\n    shadow = shadow / 9.0;\n\n    var baseColor: vec3<f32>;\n    let sampled = textureSample(texture, textureSampler, input.fragTexCoord);\n\n    if (input.fragPosWorld.y == -1.0) {\n        baseColor = vec3<f32>(0.8, 0.8, 0.8);\n    } else {\n        baseColor = sampled.rgb;\n    }\n\n    let lighting = ambient + (1.0 - shadow) * diffuse;\n\n    return vec4<f32>(baseColor * lighting, 1.0);\n}\n"}),u=e.createBindGroupLayout({label:"Main UBO Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d",multisampled:!1,sampleType:"float"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}]});this.#f=e.createBindGroupLayout({label:"Shadow and Texture Layout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d",multisampled:!1,sampleType:"depth"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"comparison"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d",multisampled:!1,sampleType:"float"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}]}),this.#l=e.createSampler({label:"Shadow Map Sampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge",minFilter:"nearest",magFilter:"nearest",mipmapFilter:"nearest",compare:"less"}),this.#u=e.createBuffer({label:"MainUBO",size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.#d=e.createBuffer({label:"LightUBO",size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.#c=e.createBindGroup({label:"Main Bind Group",layout:u,entries:[{binding:0,resource:{buffer:this.#u}},{binding:1,resource:{buffer:this.#d}},{binding:2,resource:this.#p},{binding:3,resource:this.#h}]}),this.bindGroupShadowAndTexture=this.#v(r,this.#p);const c=e.createPipelineLayout({label:"Main Pipeline Layout",bindGroupLayouts:[u,this.#f]});this.#a=e.createRenderPipeline({label:"Main Pipeline",layout:c,vertex:{module:s,entryPoint:"vs_main",buffers:[d.x]},fragment:{module:s,entryPoint:"fs_main",targets:[{format:t,blend:{color:{operation:"add",srcFactor:"one",dstFactor:"zero"},alpha:{operation:"add",srcFactor:"one",dstFactor:"zero"}},writeMask:GPUColorWrite.ALL}]},primitive:{cullMode:"back",frontFace:"ccw",topology:"triangle-list"},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"}}),this.#m=this.#g(n,a)}updateMainUBO(e){this.#e.queue.writeBuffer(this.#u,0,function(e){const t=new Float32Array(64);return t.set(e.model,0),t.set(e.view,16),t.set(e.proj,32),t.set(e.lightViewProj,48),t}(e))}updateLightUBO(e){this.#e.queue.writeBuffer(this.#d,0,function(e){const t=new Float32Array(8);return t.set(e.direction,0),t.set(e.color,4),t}(e))}resizeDepthTexture(e,t,r){this.bindGroupShadowAndTexture=this.#v(r,this.#p),this.#m=this.#g(e,t)}recordCommands(e,t,r){const n=e.beginRenderPass({label:"Main Render Pass",colorAttachments:[{view:t,loadOp:"clear",storeOp:"store",clearValue:l}],depthStencilAttachment:{view:this.#m,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});n.setPipeline(this.#a),n.setBindGroup(0,this.#c),n.setBindGroup(1,this.bindGroupShadowAndTexture);for(const e of r)n.setVertexBuffer(0,e.buffer,e.vertexOffset),n.setIndexBuffer(e.buffer,"uint16",e.indexOffset),n.drawIndexed(e.indexCount,1,0,0,0);n.end()}#v(e,t){return this.#e.createBindGroup({label:"Shadow and Texture Bind Group",layout:this.#f,entries:[{binding:0,resource:e},{binding:1,resource:this.#l},{binding:2,resource:t},{binding:3,resource:this.#h}]})}#g(e,t){return this.#e.createTexture({label:"Scene Depth Texture",size:{width:e,height:t},format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}).createView()}}class h{#e;#b;#x;#w;#y;constructor(e,t,r,n,a){this.#e=e,this.#b=new c(e,r,n),this.#x=new u(e,t,this.#b.shadowTextureView),this.#w=new p(e,t,this.#b.shadowTextureView,r,n,a),this.#y=performance.now()}resize(e,t){this.#b.resizeShadowTexture(e,t),this.#x.rebindShadowTexture(this.#b.shadowTextureView),this.#w.resizeDepthTexture(e,t,this.#b.shadowTextureView)}render(e,t,r,a){const s=this.#e.createCommandEncoder({label:"Test Render Encoder"}),u=(performance.now()-this.#y)/1e3,d=8*Math.cos(.2*u),c=8*Math.sin(.2*u),l=n.fA(d,6,c),p=o();var h,f,m,v,g,b,x,w,y,S;w=1/((f=-10)-(m=10)),y=1/((v=-10)-(g=10)),S=1/((b=-10)-(x=20)),(h=p)[0]=-2*w,h[1]=0,h[2]=0,h[3]=0,h[4]=0,h[5]=-2*y,h[6]=0,h[7]=0,h[8]=0,h[9]=0,h[10]=2*S,h[11]=0,h[12]=(f+m)*w,h[13]=(g+v)*y,h[14]=(x+b)*S,h[15]=1;const P=o();i(P,l,n.fA(0,0,0),n.fA(0,1,0));const G=o();(function(e,t,r){var n=t[0],a=t[1],o=t[2],i=t[3],s=t[4],u=t[5],d=t[6],c=t[7],l=t[8],p=t[9],h=t[10],f=t[11],m=t[12],v=t[13],g=t[14],b=t[15],x=r[0],w=r[1],y=r[2],S=r[3];e[0]=x*n+w*s+y*l+S*m,e[1]=x*a+w*u+y*p+S*v,e[2]=x*o+w*d+y*h+S*g,e[3]=x*i+w*c+y*f+S*b,x=r[4],w=r[5],y=r[6],S=r[7],e[4]=x*n+w*s+y*l+S*m,e[5]=x*a+w*u+y*p+S*v,e[6]=x*o+w*d+y*h+S*g,e[7]=x*i+w*c+y*f+S*b,x=r[8],w=r[9],y=r[10],S=r[11],e[8]=x*n+w*s+y*l+S*m,e[9]=x*a+w*u+y*p+S*v,e[10]=x*o+w*d+y*h+S*g,e[11]=x*i+w*c+y*f+S*b,x=r[12],w=r[13],y=r[14],S=r[15],e[12]=x*n+w*s+y*l+S*m,e[13]=x*a+w*u+y*p+S*v,e[14]=x*o+w*d+y*h+S*g,e[15]=x*i+w*c+y*f+S*b})(G,p,P),this.#b.updateShadowUBO({lightViewProj:G}),this.#b.recordCommands(s,t);{const d=n.fA(8*Math.cos(-.1*u),6,8*Math.sin(-.1*u)),c=o();i(c,d,n.fA(0,0,0),n.fA(0,1,0));const p=o();!function(e,t,r,n,a){var o,i=1/Math.tan(t/2);e[0]=i/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=a&&a!==1/0?(o=1/(n-a),e[10]=(a+n)*o,e[14]=2*a*n*o):(e[10]=-1,e[14]=-2*n)}(p,15*Math.PI/180,r/a,.1,100);const h={model:o(),view:c,proj:p,lightViewProj:G};this.#w.updateMainUBO(h);const f=n.vt();n.Re(f,n.fA(0,0,0),l),n.S8(f,f);const m={direction:f,color:n.fA(1,1,1)};this.#w.updateLightUBO(m),this.#w.recordCommands(s,e,t)}this.#e.queue.submit([s.finish()])}}},351:(e,t,r)=>{r.d(t,{vt:()=>s,x8:()=>u});var n,a=r(531),o=r(741),i=r(429);function s(){var e=new a.tb(4);return a.tb!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function u(e,t,r){r*=.5;var n=Math.sin(r);return e[0]=n*t[0],e[1]=n*t[1],e[2]=n*t[2],e[3]=Math.cos(r),e}n=new a.tb(4),a.tb!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0,n[3]=0);i.vt(),i.fA(1,0,0),i.fA(0,1,0),s(),s(),o.vt()},359:(e,t,r)=>{r.d(t,{q:()=>o});var n=r(429),a=r(38);class o{#S;#P;#G;#T;#B;#M;constructor(e,t="untitled"){this.#S=e,this.#P=t}parse(){return this.#U(),this.#S.split(/\r?\n/).forEach(e=>{const t=(e=>{const t=e.indexOf("#");return t>=0?e.slice(0,t):e})(e).replace(/\s\s+/g," ").trim();if(0===t.length)return;const r=t.split(" ");switch(r[0].toLowerCase()){case"o":this.#A(r);break;case"g":this.#C(r);break;case"v":this.#V(r);break;case"vt":this.#O(r);break;case"vn":this.#F(r);break;case"s":this.#_(r);break;case"f":this.#E(r);break;case"mtllib":this.#I(r);break;case"usemtl":this.#L(r)}}),this.#G}#U(){this.#G={models:[],materialLibraries:[]},this.#T="",this.#B="",this.#M=0}#D(){return 0===this.#G.models.length&&this.#G.models.push({name:this.#P,vertices:[],textureCoords:[],vertexNormals:[],faces:[]}),this.#G.models[this.#G.models.length-1]}#A(e){const t=e[1]??this.#P;this.#G.models.push({name:t,vertices:[],textureCoords:[],vertexNormals:[],faces:[]}),this.#B="",this.#M=0}#C(e){if(2!==e.length)throw new Error('Group statements must have exactly 1 argument (e.g. "g group_1").');this.#B=e[1]}#V(e){const[t="0",r="0",a="0"]=e.slice(1);this.#D().vertices.push(n.fA(parseFloat(t),parseFloat(r),parseFloat(a)))}#O(e){const[t="0",r="0"]=e.slice(1);this.#D().textureCoords.push(a.fA(parseFloat(t),parseFloat(r)))}#F(e){const[t="0",r="0",a="0"]=e.slice(1);this.#D().vertexNormals.push(n.fA(parseFloat(t),parseFloat(r),parseFloat(a)))}#_(e){if(2!==e.length)throw new Error('Smoothing group statements must have exactly 1 argument (e.g. "s 1" or "s off").');this.#M="off"===e[1].toLowerCase()?0:parseInt(e[1],10)}#E(e){if(e.length<4)throw new Error('Face statement must have at least 3 vertices (e.g. "f v1 v2 v3").');const t={material:this.#T,group:this.#B,smoothingGroup:this.#M,vertices:[]};e.slice(1).forEach(e=>{const r=e.split("/");if(r.length<1||r.length>3)throw new Error("Invalid vertex specification inside face.");let[n,a,o]=r,i=parseInt(n,10);if(0===i)throw new Error("OBJ vertex indices are 1-based and may not be zero.");i<0&&(i=this.#D().vertices.length+1+i),t.vertices.push({vertexIndex:i,textureCoordsIndex:a?parseInt(a,10):0,vertexNormalIndex:o?parseInt(o,10):0})}),this.#D().faces.push(t)}#I(e){e.length>=2&&this.#G.materialLibraries.push(e[1])}#L(e){e.length>=2&&(this.#T=e[1])}}},398:(e,t,r)=>{r.a(e,async(e,t)=>{try{var n=r(543),a=r(453),o=r(797),i=r(562),s=r(113),u=r(741),d=r(351),c=r(429),l=r(38),p=r(81),h=r(359);const f=document.getElementById("canvas"),m=new n.c,v=await a.Y.create(m),g=new o.o(f),b=await i.p.create(v,g,m.preferredFormat),x=await fetch("./assets/viking_room.png"),w=await x.blob(),y=await createImageBitmap(w),S=new s.O(b,m.preferredFormat,f.width,f.height,y);function P(e){const t=new h.q(new TextDecoder("utf-8").decode(e)),{models:r}=t.parse();if(!r.length)throw new Error("OBJ에는 최소 1개의 모델(o)이 필요합니다.");const n=r[0],a=[],o=[],i=new Map,s=u.I0(u.vt(),d.x8(d.vt(),[1,0,0],1.5*Math.PI)),p=(e,t)=>{const r=e[t-1];return c.fA(r[0],r[1],r[2])},f=(e,t)=>{const r=e[t-1];return l.fA(r[0],r[1])};for(const e of n.faces)for(const t of e.vertices){const e=`${t.vertexIndex}/${t.vertexNormalIndex}/${t.textureCoordsIndex}`;let r=i.get(e);if(void 0===r){const o=p(n.vertices,t.vertexIndex);c.ei(o,o,s);const u=t.vertexNormalIndex?p(n.vertexNormals,t.vertexNormalIndex):c.fA(0,1,0),d=t.textureCoordsIndex?f(n.textureCoords,t.textureCoordsIndex):l.vt();r=a.length,a.push({position:o,normal:u,texCoord:d}),i.set(e,r)}o.push(r)}return{vertices:a,indices:o}}function G(){const e=c.fA(0,1,0);return{vertices:[c.fA(-5,-1,-5),c.fA(5,-1,-5),c.fA(5,-1,5),c.fA(-5,-1,5)].map(t=>({position:t,normal:e,texCoord:l.fA(0,0)})),indices:[0,2,1,2,0,3]}}const T=await fetch("./assets/viking_room.obj").then(e=>e.arrayBuffer()),B=P(new Uint8Array(T)),M=G(),U=[(0,p.w)(b,B.vertices,B.indices),(0,p.w)(b,M.vertices,M.indices)];function A(){S.render(g.getCurrentTexture().createView(),U,f.width,f.height),requestAnimationFrame(A)}A(),t()}catch(C){t(C)}},1)},429:(e,t,r)=>{r.d(t,{$A:()=>d,Il:()=>l,Om:()=>u,Re:()=>i,S8:()=>s,ei:()=>c,fA:()=>o,vt:()=>a});var n=r(531);function a(){var e=new n.tb(3);return n.tb!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function o(e,t,r){var a=new n.tb(3);return a[0]=e,a[1]=t,a[2]=r,a}function i(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e}function s(e,t){var r=t[0],n=t[1],a=t[2],o=r*r+n*n+a*a;return o>0&&(o=1/Math.sqrt(o)),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e}function u(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function d(e,t,r){var n=t[0],a=t[1],o=t[2],i=r[0],s=r[1],u=r[2];return e[0]=a*u-o*s,e[1]=o*i-n*u,e[2]=n*s-a*i,e}function c(e,t,r){var n=t[0],a=t[1],o=t[2];return e[0]=n*r[0]+a*r[3]+o*r[6],e[1]=n*r[1]+a*r[4]+o*r[7],e[2]=n*r[2]+a*r[5]+o*r[8],e}var l=function(e){var t=e[0],r=e[1],n=e[2];return Math.hypot(t,r,n)};a()},453:(e,t,r)=>{r.d(t,{Y:()=>n});class n{#N;constructor(e){this.#N=e}static async create(e){const t=await e.requestAdapter();return new n(t)}requestDevice(){return this.#N.requestDevice()}}},531:(e,t,r)=>{r.d(t,{p8:()=>n,tb:()=>a});var n=1e-6,a="undefined"!=typeof Float32Array?Float32Array:Array;Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)})},543:(e,t,r)=>{r.d(t,{c:()=>n});class n{#R;preferredFormat;constructor(){if(!navigator.gpu)throw new Error("WebGPU support is not available");this.#R=navigator.gpu,this.preferredFormat=navigator.gpu.getPreferredCanvasFormat()}async requestAdapter(){const e=await this.#R.requestAdapter({powerPreference:"high-performance",forceFallbackAdapter:!1});if(!e)throw new Error("Failed to request Adapter.");return e}}},562:(e,t,r)=>{r.d(t,{p:()=>n});class n{#e;queue;constructor(e,t){this.#e=e,this.queue=t}static async create(e,t,r){const a=await e.requestDevice();return t.configure({device:a,format:r,alphaMode:"opaque"}),new n(a,a.queue)}createShaderModule(e){return this.#e.createShaderModule(e)}createPipelineLayout(e){return this.#e.createPipelineLayout(e)}createComputePipeline(e){return this.#e.createComputePipeline(e)}createRenderPipeline(e){return this.#e.createRenderPipeline(e)}createCommandEncoder(e){return this.#e.createCommandEncoder(e)}createBuffer(e){return this.#e.createBuffer(e)}createBindGroupLayout(e){return this.#e.createBindGroupLayout(e)}createBindGroup(e){return this.#e.createBindGroup(e)}createTexture(e){return this.#e.createTexture(e)}createSampler(e){return this.#e.createSampler(e)}}},741:(e,t,r)=>{r.d(t,{I0:()=>o,vt:()=>a});var n=r(531);function a(){var e=new n.tb(9);return n.tb!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function o(e,t){var r=t[0],n=t[1],a=t[2],o=t[3],i=r+r,s=n+n,u=a+a,d=r*i,c=n*i,l=n*s,p=a*i,h=a*s,f=a*u,m=o*i,v=o*s,g=o*u;return e[0]=1-l-f,e[3]=c-g,e[6]=p+v,e[1]=c+g,e[4]=1-d-f,e[7]=h-m,e[2]=p-v,e[5]=h+m,e[8]=1-d-l,e}},797:(e,t,r)=>{r.d(t,{o:()=>n});class n{#z;constructor(e){const t=e.getContext("webgpu");if(!t)throw new Error("Failed to get WebGPU context");this.#z=t}configure(e){this.#z.configure(e)}getCurrentTexture(){return this.#z.getCurrentTexture()}}},890:(e,t,r)=>{r.d(t,{k:()=>o,x:()=>a});const n=8,a={arrayStride:4*n,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"},{shaderLocation:2,offset:24,format:"float32x2"}]};function o(e){const t=new Float32Array(e.length*n);for(let r=0;r<e.length;r++){const a=e[r],o=r*n;t.set(a.position,o+0),t.set(a.normal,o+3),t.set(a.texCoord,o+6)}return t}}},o={};function i(e){var t=o[e];if(void 0!==t)return t.exports;var r=o[e]={exports:{}};return a[e](r,r.exports,i),r.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",r="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",n=e=>{e&&e.d<1&&(e.d=1,e.forEach(e=>e.r--),e.forEach(e=>e.r--?e.r++:e()))},i.a=(a,o,i)=>{var s;i&&((s=[]).d=-1);var u,d,c,l=new Set,p=a.exports,h=new Promise((e,t)=>{c=t,d=e});h[t]=p,h[e]=e=>(s&&e(s),l.forEach(e),h.catch(e=>{})),a.exports=h,o(a=>{var o;u=(a=>a.map(a=>{if(null!==a&&"object"==typeof a){if(a[e])return a;if(a.then){var o=[];o.d=0,a.then(e=>{i[t]=e,n(o)},e=>{i[r]=e,n(o)});var i={};return i[e]=e=>e(o),i}}var s={};return s[e]=e=>{},s[t]=a,s}))(a);var i=()=>u.map(e=>{if(e[r])throw e[r];return e[t]}),d=new Promise(t=>{(o=()=>t(i)).r=0;var r=e=>e!==s&&!l.has(e)&&(l.add(e),e&&!e.d&&(o.r++,e.push(o)));u.map(t=>t[e](r))});return o.r?d:i()},e=>(e?c(h[r]=e):d(p),n(s))),s&&s.d<0&&(s.d=0)},i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i(398)})();