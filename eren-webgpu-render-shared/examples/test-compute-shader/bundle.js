(()=>{"use strict";var e,t,r,n,o={377:(e,t,r)=>{r.d(t,{O:()=>d});const n={arrayStride:20,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x3"}]};var o,a="undefined"!=typeof Float32Array?Float32Array:Array;function i(e,t){var r=new a(2);return r[0]=e,r[1]=t,r}function s(e,t,r){var n=new a(3);return n[0]=e,n[1]=t,n[2]=r,n}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),o=new a(2),a!=Float32Array&&(o[0]=0,o[1]=0),function(){var e=new a(3);a!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0)}();const u={r:.1921,g:.302,b:.4745,a:1},c=[{pos:i(-.5,-.5),color:s(1,0,0)},{pos:i(.5,-.5),color:s(0,1,0)},{pos:i(.5,.5),color:s(0,0,1)},{pos:i(-.5,.5),color:s(1,1,1)}],f=[0,1,2,2,3,0];class p{#e;#t;#r;#n;#o;#a;#i;constructor(e,t){this.#e=e;let r=e.createShaderModule({label:"Test Shader",code:"const EYE_POS: vec3<f32> = vec3<f32>(2.0, 2.0, 2.0);\nconst CENTER_POS: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);\nconst UP_VEC: vec3<f32> = vec3<f32>(0.0, 0.0, 1.0); // Z-up\n\nstruct Settings {\n    time: f32,\n    aspect_ratio: f32,\n    _padding: vec2<f32>, // Alignment for 16-byte layout\n}\n\n@group(0) @binding(0)\nvar<uniform> settings: Settings;\n\n// 결과를 저장할 StorageBufferObject\nstruct StorageBufferObject {\n    model : mat4x4<f32>,\n    view  : mat4x4<f32>,\n    proj  : mat4x4<f32>,\n};\n\n@group(0) @binding(1)\nvar<storage, read_write> ssbo : StorageBufferObject;\n\nfn rotationZ(rad: f32) -> mat4x4<f32> {\n    let s = sin(rad);\n    let c = cos(rad);\n    return mat4x4<f32>(\n        vec4<f32>( c,  s, 0.0, 0.0),\n        vec4<f32>(-s,  c, 0.0, 0.0),\n        vec4<f32>( 0.0, 0.0, 1.0, 0.0),\n        vec4<f32>( 0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nfn lookAt(eye: vec3<f32>, center: vec3<f32>, up: vec3<f32>) -> mat4x4<f32> {\n    let f = normalize(center - eye);\n    let s = normalize(cross(f, up));\n    let u = cross(s, f);\n\n    return mat4x4<f32>(\n        vec4<f32>(s.x, u.x, -f.x, 0.0),\n        vec4<f32>(s.y, u.y, -f.y, 0.0),\n        vec4<f32>(s.z, u.z, -f.z, 0.0),\n        vec4<f32>(-dot(s, eye), -dot(u, eye), dot(f, eye), 1.0)\n    );\n}\n\nfn perspectiveRH(fovy: f32, aspect: f32, znear: f32, zfar: f32) -> mat4x4<f32> {\n    let t = 1.0 / tan(fovy * 0.5);\n    return mat4x4<f32>(\n        vec4<f32>(t / aspect, 0.0, 0.0, 0.0),\n        vec4<f32>(0.0, t, 0.0, 0.0),\n        vec4<f32>(0.0, 0.0, zfar / (znear - zfar), -1.0),\n        vec4<f32>(0.0, 0.0, (znear * zfar) / (znear - zfar), 0.0)\n    );\n}\n\n@compute @workgroup_size(1)\nfn compute_mvp() {\n    // Model matrix: rotate around Z axis over time\n    let model = rotationZ(radians(90.0) * settings.time);\n\n    // View matrix: look from eye to center\n    let view = lookAt(EYE_POS, CENTER_POS, UP_VEC);\n\n    // Projection matrix: perspective with Y-flip\n    let proj = perspectiveRH(radians(45.0), settings.aspect_ratio, 0.1, 10.0);\n\n    // Write to buffer\n    ssbo.model = model;\n    ssbo.view = view;\n    ssbo.proj = proj;\n}\n\n// 정점 입력 구조체 (vertex buffer layout에서 제공)\nstruct VertexInput {\n    @location(0) inPosition : vec2<f32>,\n    @location(1) inColor    : vec3<f32>,\n};\n\n// 정점 출력 구조체\nstruct VertexOutput {\n    @builtin(position) position : vec4<f32>,\n    @location(0) fragColor : vec3<f32>,\n};\n\n@vertex\nfn vs_main(input : VertexInput) -> VertexOutput {\n    var output : VertexOutput;\n    \n    // GLSL과 동일한 방식의 모델-뷰-프로젝션 변환\n    let pos = vec4<f32>(input.inPosition, 0.0, 1.0);\n    output.position = ssbo.proj * ssbo.view * ssbo.model * pos;\n    \n    output.fragColor = input.inColor;\n    return output;\n}\n\n@fragment\nfn fs_main(@location(0) fragColor : vec3<f32>) -> @location(0) vec4<f32> {\n    return vec4<f32>(fragColor, 1.0);\n}\n"});this.#a=e.createBuffer({label:"UBO Buffer",size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const o=e.createBuffer({label:"SSBO Buffer",size:192,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),a=e.createBindGroupLayout({label:"Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"storage"}}]});this.#t=e.createBindGroup({label:"Bind Group",layout:a,entries:[{binding:0,resource:{buffer:this.#a}},{binding:1,resource:{buffer:o}}]});let i=e.createPipelineLayout({label:"Test Pipeline Layout",bindGroupLayouts:[a]});this.#r=e.createComputePipeline({label:"Test Compute Pipeline",layout:i,compute:{module:r,entryPoint:"compute_mvp"}}),this.#n=e.createRenderPipeline({label:"Test Pipeline",layout:i,vertex:{module:r,entryPoint:"vs_main",buffers:[n]},fragment:{module:r,entryPoint:"fs_main",targets:[{format:t}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint16"}}),this.#o=function(e){const t=function(e){const t=new Float32Array(5*e.length);for(let r=0;r<e.length;r++){const n=5*r;t.set(e[r].pos,n+0),t.set(e[r].color,n+2)}return t}(c),r=t.length,n=f.length,o=4*r+3&-4,a=o+2*n,i=e.createBuffer({label:"Test Buffer",size:a,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),s=new Uint8Array(i.getMappedRange());return new Float32Array(s.buffer).set(t),new Uint16Array(s.buffer,o,n).set(f),i.unmap(),{buffer:i,vertexOffset:0,indexOffset:o,indexCount:n}}(e),this.#i=Date.now()}#s(e,t){const r={time:(performance.now()-this.#i)/1e3,aspect_ratio:e/t,_padding:[0,0]};this.#e.queue.writeBuffer(this.#a,0,function(e){const t=new Float32Array(4);return t[0]=e.time,t[1]=e.aspect_ratio,t[2]=e._padding[0],t[3]=e._padding[1],t}(r))}recordCommands(e,t,r,n){this.#s(r,n);const o=e.beginComputePass({label:"Test Compute Pass"});o.setPipeline(this.#r),o.setBindGroup(0,this.#t),o.dispatchWorkgroups(1,1,1),o.end();const a=e.beginRenderPass({label:"Test Render Pass",colorAttachments:[{view:t,loadOp:"clear",storeOp:"store",clearValue:u}]});a.setPipeline(this.#n),a.setVertexBuffer(0,this.#o.buffer,this.#o.vertexOffset),a.setIndexBuffer(this.#o.buffer,"uint16",this.#o.indexOffset),a.setBindGroup(0,this.#t),a.drawIndexed(this.#o.indexCount,1,0,0,0),a.end()}}class d{#e;#u;constructor(e,t){this.#e=e,this.#u=new p(e,t)}render(e,t,r){const n=this.#e.createCommandEncoder({label:"Test Render Encoder"});this.#u.recordCommands(n,e,t,r),this.#e.queue.submit([n.finish()])}}},412:(e,t,r)=>{r.a(e,async(e,t)=>{try{var n=r(543),o=r(453),a=r(797),i=r(562),s=r(377);const u=document.getElementById("canvas"),c=new n.c,f=await o.Y.create(c),p=new a.o(u),d=await i.p.create(f,p,c.preferredFormat),l=new s.O(d,c.preferredFormat);function m(){l.render(p.getCurrentTexture().createView(),u.width,u.height),requestAnimationFrame(m)}m(),t()}catch(v){t(v)}},1)},453:(e,t,r)=>{r.d(t,{Y:()=>n});class n{#c;constructor(e){this.#c=e}static async create(e){const t=await e.requestAdapter();return new n(t)}requestDevice(){return this.#c.requestDevice()}}},543:(e,t,r)=>{r.d(t,{c:()=>n});class n{#f;preferredFormat;constructor(){if(!navigator.gpu)throw new Error("WebGPU support is not available");this.#f=navigator.gpu,this.preferredFormat=navigator.gpu.getPreferredCanvasFormat()}async requestAdapter(){const e=await this.#f.requestAdapter({powerPreference:"high-performance",forceFallbackAdapter:!1});if(!e)throw new Error("Failed to request Adapter.");return e}}},562:(e,t,r)=>{r.d(t,{p:()=>n});class n{#e;queue;constructor(e,t){this.#e=e,this.queue=t}static async create(e,t,r){const o=await e.requestDevice();return t.configure({device:o,format:r,alphaMode:"opaque"}),new n(o,o.queue)}createShaderModule(e){return this.#e.createShaderModule(e)}createPipelineLayout(e){return this.#e.createPipelineLayout(e)}createComputePipeline(e){return this.#e.createComputePipeline(e)}createRenderPipeline(e){return this.#e.createRenderPipeline(e)}createCommandEncoder(e){return this.#e.createCommandEncoder(e)}createBuffer(e){return this.#e.createBuffer(e)}createBindGroupLayout(e){return this.#e.createBindGroupLayout(e)}createBindGroup(e){return this.#e.createBindGroup(e)}createTexture(e){return this.#e.createTexture(e)}}},797:(e,t,r)=>{r.d(t,{o:()=>n});class n{#p;constructor(e){const t=e.getContext("webgpu");if(!t)throw new Error("Failed to get WebGPU context");this.#p=t}configure(e){this.#p.configure(e)}getCurrentTexture(){return this.#p.getCurrentTexture()}}}},a={};function i(e){var t=a[e];if(void 0!==t)return t.exports;var r=a[e]={exports:{}};return o[e](r,r.exports,i),r.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",r="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",n=e=>{e&&e.d<1&&(e.d=1,e.forEach(e=>e.r--),e.forEach(e=>e.r--?e.r++:e()))},i.a=(o,a,i)=>{var s;i&&((s=[]).d=-1);var u,c,f,p=new Set,d=o.exports,l=new Promise((e,t)=>{f=t,c=e});l[t]=d,l[e]=e=>(s&&e(s),p.forEach(e),l.catch(e=>{})),o.exports=l,a(o=>{var a;u=(o=>o.map(o=>{if(null!==o&&"object"==typeof o){if(o[e])return o;if(o.then){var a=[];a.d=0,o.then(e=>{i[t]=e,n(a)},e=>{i[r]=e,n(a)});var i={};return i[e]=e=>e(a),i}}var s={};return s[e]=e=>{},s[t]=o,s}))(o);var i=()=>u.map(e=>{if(e[r])throw e[r];return e[t]}),c=new Promise(t=>{(a=()=>t(i)).r=0;var r=e=>e!==s&&!p.has(e)&&(p.add(e),e&&!e.d&&(a.r++,e.push(a)));u.map(t=>t[e](r))});return a.r?c:i()},e=>(e?f(l[r]=e):c(d),n(s))),s&&s.d<0&&(s.d=0)},i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i(412)})();