(()=>{"use strict";function r(r,e,t){const n=r.createShader(e);if(!n)throw new Error("Failed to create shader");if(r.shaderSource(n,t),r.compileShader(n),!r.getShaderParameter(n,r.COMPILE_STATUS)){const e=r.getShaderInfoLog(n);throw r.deleteShader(n),new Error("Failed to compile shader: "+e)}return n}const e=document.querySelector("#canvas").getContext("webgl2");if(!e)throw new Error("WebGL2 not supported");const t=function(r,e,t){const n=r.createProgram();if(r.attachShader(n,e),r.attachShader(n,t),r.linkProgram(n),!r.getProgramParameter(n,r.LINK_STATUS)){const e=r.getProgramInfoLog(n);throw r.deleteProgram(n),new Error("Failed to link program: "+e)}return n}(e,r(e,e.VERTEX_SHADER,"#version 300 es\n     \n// attribute는 정점 셰이더에 대한 입력(in)입니다.\n// 버퍼로부터 데이터를 받습니다.\nin vec4 a_position;\n \n// 모든 셰이더는 main 함수를 가지고 있습니다.\nvoid main() {\n \n  // gl_Position은 정점 셰이더가 설정해 주어야 하는 내장 변수입니다.\n  gl_Position = a_position;\n}\n"),r(e,e.FRAGMENT_SHADER,'#version 300 es\n \n// 프래그먼트 셰이더는 기본 정밀도를 가지고 있지 않으므로 선언을 해야합니다.\n// highp는 기본값으로 적당합니다. "높은 정밀도(high precision)"를 의미합니다.\nprecision highp float;\n \n// 프래그먼트 셰이더는 출력값을 선언 해야합니다.\nout vec4 outColor;\n \nvoid main() {\n  // 붉은-보라색 상수로 출력값을 설정합니다.\n  outColor = vec4(1, 0, 0.5, 1);\n}\n')),n=e.getAttribLocation(t,"a_position"),o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,0,.5,.7,0]),e.STATIC_DRAW);const a=e.createVertexArray();e.bindVertexArray(a),e.enableVertexAttribArray(n);{const r=2,t=e.FLOAT,o=!1,a=0,i=0;e.vertexAttribPointer(n,r,t,o,a,i)}e.viewport(0,0,e.canvas.width,e.canvas.height),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT),e.useProgram(t),e.bindVertexArray(a);{const r=e.TRIANGLES,t=0,n=3;e.drawArrays(r,t,n)}})();